slug: sentinel-for-terraform-v1
id: 48umckahecbz
type: track
title: Sentinel for Terraform (v1)
teaser: Learn how to write and test Sentinel policies for Terraform.
description: |-
  Sentinel allows customers to implement policy-as-code in the same way that Terraform implements infrastructure-as-code.

  Governance and security teams can write Sentinel policies to restrict what can be provisioned in Terraform Cloud and Terraform Enterprise workspaces. Sentinel allows these teams to control costs and enforce security standards.

  In this track, you will write and test policies that restrict resources, data sources, and modules provisioned by Terraform in AWS, Azure, and GCP. This version of the track uses the older v1 versions of the `tfplan`, `tfstate`, and `tfconfig` Sentinel imports which can be used with both Terraform 0.11 and 0.12. If you are only using Terraform 0.12, we recommend you use the [v2 version](https://play.instruqt.com/hashicorp/tracks/sentinel-for-terraform-v2) of this track which uses the newer v2 versions of those imports.

  This track is intended for use with these PowerPoint [slides](https://storage.googleapis.com/instruqt-hashicorp-tracks/sentinel-shared/Sentinel-for-Terraform-v1.pptx) which you should download.

  We recommend starting this track when you can set aside at least 2 hours of uninterrupted time. (The total allocation of 4 hours is for use of the track in a workshop setting in which slides are alternated with the track challenges.) If you find yourself running out of time or are interrupted, we recommend saving all your completed policies outside the track so that you can quickly restore them if forced to begin the track again.
icon: https://storage.googleapis.com/instruqt-hashicorp-tracks/logo/terraform.png
tags:
- terraform
- sentinel
owner: hashicorp
developers:
- roger@hashicorp.com
private: false
published: true
challenges:
- slug: sentinel-cli
  id: rtrwefuyvzkv
  type: challenge
  title: The Sentinel CLI
  teaser: Learn about the Sentinel CLI commands.
  assignment: |-
    The Sentinel Command Line Interface (CLI) allows you to apply and test Sentinel policies including those that use mocks generated from Terraform Cloud plans.

    Let's start with some basic Sentinel commands, running them in the "Sentinel CLI" tab on the left.

    Check the version of Sentinel running on your machine:<br>
    `sentinel version`

    See the list of Sentinel CLI commands:<br>
    `sentinel`

    Get help for the "sentinel apply" command:<br>
    `sentinel apply -h`<br>
    Note that you can also use the "-help" and "--help" flags instead of "-h".

    Get help for the "sentinel test" command:<br>
    `sentinel test -h`

    The "sentinel apply" and "sentinel test" commands both evaluate a Sentinel policy, but the latter tests it against multiple test case files.
  notes:
  - type: text
    contents: |-
      The Sentinel Command Line Interface (CLI) allows you to apply and test Sentinel policies including those that use mocks generated from Terraform Cloud and Terraform Enterprise plans.

      To learn more, see the docs here: https://docs.hashicorp.com/sentinel

      You can download the Sentinel CLI here:
      https://docs.hashicorp.com/sentinel/downloads
  - type: text
    contents: |-
      Installing Sentinel on your laptop or workstation is easy. You simply download the zip file, unpack it, and place it somewhere in your PATH.

      Check out this tutorial for step-by-step instructions:
      https://docs.hashicorp.com/sentinel/intro/getting-started

      We've launched the Sentinel CLI in a Docker container so that you don't need to download or install it.
  tabs:
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 600
- slug: sentinel-first-policy
  id: 7xd35cxzab29
  type: challenge
  title: Run Your First Sentinel Policy
  teaser: Apply and test your first Sentinel policy.
  assignment: |-
    Now that you are familiar with the Sentinel CLI commands, let's apply and test your first Sentinel policy.

    Take a look at the require-even-number.sentinel policy on the "First Policy" tab. This checks that a parameter called "the_number" is an even integer; it's default value is 1.

    Apply the require-even-number.sentinel policy with the default value of 1 on the "Sentinel CLI" tab:<br>
    `sentinel apply require-even-number.sentinel`<br>
    This will fail since 1 is an odd number.

    Apply the require-even-number.sentinel policy with a value of 2:<br>
    `sentinel apply -param the_number=2 require-even-number.sentinel`<br>
    This will pass since 2 is an even number. You could also add `-trace` before the name of the policy to make Sentinel print more information.

    Now, we will test the policy with the "sentinel test" command using test cases. For any policy, the test cases must be placed under the directory test/<policy\> under the directory containing the policy where <policy\> is the name of the policy without the ".sentinel" extension.

    Edit the fail.json test case for the require-even-number.sentinel policy on the "Test Cases" tab, replacing `<an_odd_number>` with any odd number.  Save the fail.json file.

    Edit the pass.json test case for the require-even-number.sentinel policy on the "Test Cases" tab, replacing `<an_even_number>` with any even number. Save the pass.json file.

    Test the require-even-number.sentinel policy against both test cases on the "Sentinel CLI" tab:<br>
    `sentinel test -run=number -verbose`<br>
    Both test cases should pass and show you the numbers that were used.

    Note that when specifying a policy with the "-run" argument, you can match any portion of the policy name.
  notes:
  - type: text
    contents: |-
      The Sentinel "apply" command lets you evaluate Sentinel policies:
      https://docs.hashicorp.com/sentinel/commands/apply

      The Sentinel "test" command lets you test a Sentinel policy against multiple test cases:
      https://docs.hashicorp.com/sentinel/commands/test

      Both commands use Sentinel CLI configuration files:
      https://docs.hashicorp.com/sentinel/commands/config
  tabs:
  - title: First Policy
    type: code
    hostname: sentinel
    path: /root/require-even-number.sentinel
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/test/require-even-number/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1200
- slug: exercise-1
  id: noubkwg4jmwk
  type: challenge
  title: Exercise 1
  teaser: Restrict Vault authentication methods.
  assignment: |-
    In this challenge, you will complete [Exercise 1](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#exercise-1) from the "Writing and Testing Sentinel Policies for Terraform" guide.

    Your task is to write and test a Sentinel policy that restricts the Vault authentication methods (backends) provisioned by the `vault_auth_backend` resource of Terraform's Vault Provider to the following choices: Azure, Kubernetes, GitHub, and AppRole.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it. The policy uses simplified versions of the `find_resources_from_plan` and `validate_attribute_in_list` functions from this sample [policy](https://github.com/hashicorp/terraform-guides/blob/master/governance/second-generation/aws/restrict-ec2-instance-type.sentinel).

    If you would like to learn more about those methods, see the [find_resources_from_plan](https://github.com/hashicorp/terraform-guides/blob/master/governance/second-generation/common-functions/plan/find_resources_from_plan.md) and [validate_attribute_in_list](https://github.com/hashicorp/terraform-guides/blob/master/governance/second-generation/common-functions/plan/validate_attribute_in_list.md) doc pages.

    At any point while solving the challenge, you can click the green `Check` button to get a hint suggesting something that you still need to do.

    Open the restrict-vault-auth-methods.sentinel policy on the "Policy" tab. After two import statements and the functions mentioned above, you'll see several placeholders in angular brackets. You need to replace those placeholders with suitable expressions.

    Replace `<method1>`, `<method2>`, `<method3>`, and `<method4>` in the `allowed_methods` list with suitable values. If you did not read the second screen while this challenge was loading, we suggest you read it now by clicking on the note icon in the upper right corner and then clicking the right arrow icon. Click the X icon to return to the challenge. Be sure to check the Vault auth method pages to see what the correct values are and note that case matters.

    You now need to replace `<resource_type>`, `<attribute>`, and `<list>` in the call to the `validate_attribute_in_list` function on line 77. We've already told you the resource type above.  You can figure out the attribute you want to restrict by reading the [auth_backend](https://www.terraform.io/docs/providers/vault/r/auth_backend.html) documentation. The name of the list to use should be obvious.

    After making all the substitutions, save the restrict-vault-auth-methods.sentinel policy.

    Now open the test cases and mock files on the "Test Cases" tab. You'll see that fail.json refers to the mock-tfplan-fail.sentinel mock file and expects the main rule to return false. You'll also see that pass.json refers to the mock-tfplan-pass.sentinel mock file and expects the main rule to return true.

    The mock files are simplified versions of a mock generated from a Terraform Cloud run done against Terraform code that used the Vault provider to create some auth methods. The mock-tfplan-fail.sentinel mock file creates instances of the Kubernetes, GitHub, and AWS auth methods; the first two are allowed, but the third is not. The mock-tfplan-pass.sentinel mock file creates instances of the Kubernetes, GitHub, and Azure auth methods, all of which are allowed.

    Finally, test your policy:<br>
    `sentinel test -run=vault -verbose`<br>
    Both test cases should pass with green output. Additionally, the fail.json test case should print a violation message for the aws auth method.

    If both test cases did not pass, or if Sentinel reported errors for specific lines of the policy, fix your policy and try testing it again until both test cases do pass.
  notes:
  - type: text
    contents: |-
      In this challenge, you will complete the first of five exercises from the [Writing and Testing Sentinel Policies for Terraform](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform) guide

      We recommend reviewing slides 54-64 of the Sentinel-for-Terraform-v1.pptx presentation or reading the [Step 5: Writing a New Sentinel Policy](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#step-5) section of the "Writing and Testing Sentinel Policies for Terraform" guide. You'll be using the [tfplan](https://www.terraform.io/docs/cloud/sentinel/import/tfplan.html) import just as the sample policy does.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it after you finish it.
  - type: text
    contents: |-
      Your task is to write and test a Sentinel policy that restricts the Vault authentication methods (backends) provisioned by Terraform's Vault Provider.

      Don't worry if you don't know much about Vault. You can find the information you need in these URLs:
      https://www.terraform.io/docs/providers/vault/r/auth_backend.html
      https://www.vaultproject.io/docs/auth/index.html

      If you look at the links for various Vault auth methods under the second of these links, you'll see that the `vault auth enable` command always specifies the auth method type with a single lower-case string identical to or similar to the full name of the auth method. These strings are what the Vault Provider also uses when creating Vault auth methods.
  tabs:
  - title: Policy
    type: code
    hostname: sentinel
    path: /root/restrict-vault-auth-methods.sentinel
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/test/restrict-vault-auth-methods/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: exercise-2
  id: mzcxgjqyacvp
  type: challenge
  title: Exercise 2
  teaser: Restrict AWS IAM access keys.
  assignment: |-
    In this challenge, you will complete [Exercise 2](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#exercise-2) from the "Writing and Testing Sentinel Policies for Terraform" guide.

    Your task is to write and test a Sentinel policy that requires that all AWS IAM access keys provisioned by Terraform's AWS Provider include a PGP key. This means that a specific attribute on a specific resource of that provider should not be `null` or an empty string (`""`).

    Note: The PGP key used for creating an AWS IAM access key can be given in the format "keybase:(.*)" or by providing a base-64 encoded PGP public key. For this exercise, you do not have to validate that the PGP key has either form, but if you want to make things a bit more challenging and realistic, you can add an extra condition to check that it starts with "keybase:".

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

    At any point while solving the challenge, you can click the green `Check` button to get a hint suggesting something that you still need to do.

    Open the require-access-keys-use-pgp.sentinel policy on the "Policy" tab. After two import statements and the `find_resources_from_plan` function you've already seen in other policies, you'll see a `validate_keys` function with several placeholders in angular brackets. You need to replace those placeholders with suitable expressions.

    Replace `<resource_type>` in the definition of the `validate_keys` function with a suitable resource type from the AWS provider. If you did not read the second screen while this challenge was loading, we suggest you read it now by clicking on the note icon in the upper right corner and then clicking the right arrow icon. Click the X icon to return to the challenge.

    Now that you have found the documentation page for the resource you are restricting, you can determine the specific attribute that is used to set a PGP key on an AWS IAM access key.

    You now need to replace `<condition>` in the definition of the `validate_keys` function with a condition that ensures that this attribute is neither `null` nor the empty string (`""`). You could use two conditions joined with the `and` operator or use a single condition with the `in` operator to check that the attribute is not in the list `[null, ""]`. You'll definitely need to use the `else` operator at least once to convert the `undefined` value to either `null` or `""` to handle the situation when the attribute is missing from one of the mock files.

    You now need to replace `<expression>` in the definition of the `validate_keys` function with a suitable expression representing the value of the PGP key if one was found. You would have already used this expression when building your condition.

    Now that you've completed the `validate_keys` function, you need to call it in the Rules section of the policy, replacing `<function>`.

    After making all the above substitutions, save the require-access-keys-use-pgp.sentinel policy.

    Now open the test cases and mock files on the "Test Cases" tab. You'll see that we've actually included 3 fail test cases with 3 corresponding mock files. Using multiple fail test cases allows us to test multiple ways in which a policy could fail. In this case, we're testing the attribute being set to `null`, being set to the empty string (`""`), and missing. Of course, we've also included a pass test case and a corresponding mock file that does include the desired attribute with an allowed value.

    Finally, test your policy:<br>
    `sentinel test -run=keys -verbose`<br>
    All 4 test cases should pass with green output. Additionally, the 3 fail test cases should print violation messages.

    If all 4 test cases did not pass, or if Sentinel reported errors for specific lines of the policy, fix your policy and try testing it again until all 4 test cases do pass. If you used two conditions, try changing their order. If your conditions do not have the `else` operator, add it.
  notes:
  - type: text
    contents: |-
      In this challenge, you will complete the second of five exercises from the [Writing and Testing Sentinel Policies for Terraform](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform) guide.

      We recommend reviewing slides 25-31 of the Sentinel-for-Terraform-v1.pptx presentation or reading the [Some Useful Sentinel Operators, Functions, and Concepts](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#some-useful-sentinel-operators-functions-and-concep) section of the "Writing and Testing Sentinel Policies for Terraform" guide. Pay special attention to the use of the Sentinel operators [and](https://docs.hashicorp.com/sentinel/language/spec/#logical-operators) and [else](https://docs.hashicorp.com/sentinel/language/spec/#else-operator).

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.
  - type: text
    contents: |-
      Your task is to write and test a Sentinel policy that requires that all AWS IAM access keys provisioned by Terraform's AWS Provider include a PGP key.

      Don't worry if you don't know much about AWS. You can find the information you need in this URL: https://www.terraform.io/docs/providers/aws/index.html

      You can use the filter link at the top of the left-hand menu on that page to search for resources that have "access". There is only one good match that also has "key". Click on it to see what attributes are available for it.
  tabs:
  - title: Policy
    type: code
    hostname: sentinel
    path: /root/require-access-keys-use-pgp.sentinel
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/test/require-access-keys-use-pgp/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 2400
- slug: exercise-3
  id: nx6uucacmadx
  type: challenge
  title: Exercise 3
  teaser: Restrict domains of AWS Certificate Manager (ACM) Certificates.
  assignment: |-
    In this challenge, you will complete [Exercise 3](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#exercise-3) from the "Writing and Testing Sentinel Policies for Terraform" guide.

    Your task is to write and test a Sentinel policy that requires that all AWS Certificate Manager (ACM) Certificates referenced by a data source in Terraform's AWS Provider have domains that are subdomains of "hashidemos.io".

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

    At any point while solving the challenge, you can click the green `Check` button to get a hint suggesting something that you still need to do.

    Open the restrict-acm-certificate-domains.sentinel policy on the "Policy" tab. After two import statements and a `find_data_sources_from_state` function, you'll see a `validate_certs` function with several placeholders in angular brackets. You need to replace those placeholders with suitable expressions.

    If you would like to learn more about the first function, see this [doc](https://github.com/hashicorp/terraform-guides/blob/master/governance/second-generation/common-functions/state/find_datasources_from_state.md).

    Replace `<data_source_type>` in the definition of the `validate_certs` function with a suitable data source type from the AWS provider. If you did not read the second screen while this challenge was loading, we suggest you read it now by clicking on the note icon in the upper right corner and then clicking the right arrow icon. Click the X icon to return to the challenge.

    Now that you have found the documentation page for the data source you are restricting, you can determine the specific attribute that is used to set the domain on an ACM certificate. Note that when referring to an attribute in the `tfstate` import, you have to use `attr` instead of `applied`.

    You now need to replace `<condition>` in the definition of the `validate_certs` function with a condition that validates that the domain of the ACM certificate is a subdomain of "hashidemos.io". You can use the `has_suffix` method of the `strings` import or the `matches` operator. If you use the latter read the hint for Exercise 3 in the "Writing and Testing Sentinel Policies for Terraform" guide.

    You now need to replace `<expression>` in the definition of the `validate_certs` function twice with a suitable expression representing the value of the domain. You would have already used this expression when building your condition.

    Now that you've completed the `validate_certs` function, you need to call it in the Rules section of the policy, replacing `<boolean_variable>` and `<function>`. You also need to replace `<boolean_variable>` in the main rule. You could call the boolean variable almost anything, but we recommend `certs_validated`.

    After making all the above substitutions, save the restrict-acm-certificate-domains.sentinel policy.

    Now open the test cases and mock files on the "Test Cases" tab. You'll see that fail.json refers to the mock-tfstate-fail.sentinel mock file and expects the main rule to return false. You'll also see that pass.json refers to the mock-tfstate-pass.sentinel mock file and expects the main rule to return true.

    Finally, test your policy:<br>
    `sentinel test -run=acm -verbose`<br>
    Both test cases should pass with green output. Additionally, they will both print messages indicating whether domains were valid or not.

    If both test cases did not pass, or if Sentinel reported errors for specific lines of the policy, fix your policy and try testing it again until both test cases do pass.
  notes:
  - type: text
    contents: |-
      In this challenge, you will complete the third of five exercises from the [Writing and Testing Sentinel Policies for Terraform](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform) guide.

      We recommend reviewing slides 90-91 of the Sentinel-for-Terraform-v1.pptx presentation or reading the "Evaluating Data Sources in Sentinel Policies" section of that guide which is between exercises 2 and 3. In this exercise, you will use the [tfstate](https://www.terraform.io/docs/cloud/sentinel/import/tfstate.html) import.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.
  - type: text
    contents: |-
      Your task is to write and test a Sentinel policy that requires that all AWS Certificate Manager (ACM) Certificates referenced by a data source in Terraform's AWS Provider have domains that are subdomains of "hashidemos.io".

      As in Exercise 2, you can look at the [AWS Provider](https://www.terraform.io/docs/providers/aws/index.html) documentation to search for the relevant data source.

      You can use the filter link at the top of the left-hand menu on that page to search for a data source that has "acm". Click on it to see what attributes are available for it.

      You might also find the documentation for the Sentinel [matches operator](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) and [strings import](https://docs.hashicorp.com/sentinel/imports/strings) useful.
  tabs:
  - title: Policy
    type: code
    hostname: sentinel
    path: /root/restrict-acm-certificate-domains.sentinel
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/test/restrict-acm-certificate-domains/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 2400
- slug: exercise-4
  id: ehxdizay0yrs
  type: challenge
  title: Exercise 4
  teaser: Restrict images used by Google Cloud Platform compute instances.
  assignment: |-
    In this challenge, you will complete [Exercise 4](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#exercise-4) from the "Writing and Testing Sentinel Policies for Terraform" guide.

    Your task is to write and test a Sentinel policy that requires Google Cloud Platform (GCP) compute instances provisioned by Terraform's Google Provider to use the public image "debian-cloud/debian-9". In a real-world policy, you would allow multiple images, but we wanted to keep things simple for this exercise.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

    At any point while solving the challenge, you can click the green `Check` button to get a hint suggesting something that you still need to do.

    Open the restrict-gcp-instance-image.sentinel policy on the "Policy" tab. After three import statements and a `find_resources_from_plan` function, you'll see a `validate_images` function with several placeholders in angular brackets. You need to replace those placeholders with suitable expressions.

    Replace `<resource_type>` in the definition of the `validate_images` function with the correct resource type from the Google provider.

    Now that you have found the documentation page for the resource you are restricting, you can determine the specific attribute that is used to set the image on a Google compute instance. This attribute is nested inside the `initialize_params` block which is itself contained in the `boot_disk` block.

    In Sentinel, a block is treated as a list of maps. So, we use `r.applied.boot_disk[0].initialize_params` to refer to the `initialize_params` block of the first map inside the `boot_disk` block. We use the `types` import to check if that expression is a list since we will try to access elements of it in the next line and would cause an error if it is not a list (which would be the case if it were missing or `null`). We did not need to check the type of `boot_disk` because it is a required attribute of the resource.

    You now need to replace two occurences of `<expression_1>` in the `validate_images` function with a complex expression that refers to the value of the image set in the `initialize_params` block. In addition to specifying the correct attribute of that block, keep in mind that `initialize_params` needs to be indexed just like `boot_disk` was indexed.

    Next, you now need to replace two occurences of `<expression_2>` in the `validate_images` function with the specific image we are mandating. (See the second paragraph above for the value to use.)

    Now that you've completed the `validate_images` function, you need to call it in the Rules section of the policy, replacing `<add_validation_function_call>` with a line that calls the function and assigns the result to a boolean variable. You could call the boolean variable almost anything, but we recommend `images_validated`.

    Finally, you need to replace `<add_main_rule>` with a main rule that evaluates your boolean variable. This will look very similar to the main rule in your other policies.

    After making all the above substitutions, save the restrict-gcp-instance-image.sentinel policy.

    Now open the test cases and mock files on the "Test Cases" tab. You'll see that fail.json refers to the mock-tfplan-fail.sentinel mock file and expects the main rule to return false. You'll also see that pass.json refers to the mock-tfplan-pass.sentinel mock file and expects the main rule to return true.

    Finally, test your policy:<br>
    `sentinel test -run=gcp -verbose`<br>
    Both test cases should pass with green output. Additionally, the fail test case will print a violation warning.

    If both test cases did not pass, or if Sentinel reported errors for specific lines of the policy, fix your policy and try testing it again until both test cases do pass.
  notes:
  - type: text
    contents: |-
      In this challenge, you will complete the fourth of five exercises from the [Writing and Testing Sentinel Policies for Terraform](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform) guide.

      We recommend reviewing slides 88-89 of the Sentinel-for-Terraform-v1.pptx presentation or reading the [Dealing with Lists, Maps, and Blocks](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#dealing-with-lists-maps-and-blocks) section of that guide. In this exercise, you will learn how to evaluate an attribute that is contained in a block contained in another block of a resource. A block is treated by Sentinel as a list of maps.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.
  - type: text
    contents: |-
      Your task is to write and test a Sentinel policy that requires Google Cloud Platform (GCP) compute instances provisioned by Terraform's Google Provider to use the public image "debian-cloud/debian-9". In a real-world policy, you would allow multiple images, but we wanted to keep things simple for this exercise.

      Don't worry if you don't know much about GCP. You can look at the [Google Provider](https://www.terraform.io/docs/providers/google/index.html) documentation to find the relevant GCP resource. Search for `compute_instance` and then determine attributes available for it. (Be sure to pick a resource and not a data source with the same name.)

      You might also find the documentation for Sentinel [lists](https://docs.hashicorp.com/sentinel/language/lists), [maps](https://docs.hashicorp.com/sentinel/language/maps), and the [types import](https://docs.hashicorp.com/sentinel/imports/types) useful.
  tabs:
  - title: Policy
    type: code
    hostname: sentinel
    path: /root/restrict-gcp-instance-image.sentinel
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/test/restrict-gcp-instance-image/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 2400
- slug: exercise-5
  id: xryhab0y4fxs
  type: challenge
  title: Exercise 5
  teaser: Only allow modules from the Private Module Registry.
  assignment: |-
    In this challenge, you will complete [Exercise 5](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#exercise-5) from the "Writing and Testing Sentinel Policies for Terraform" guide.

    Your task is to write and test a Sentinel policy that requires that all modules loaded by the root module come from the [Private Module Registry](https://www.terraform.io/docs/cloud/registry/index.html) (PMR) of a Terraform Cloud organization. You will use the [tfconfig](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig.html) import to do that.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it. The mocks simulate the use of two Azure modules.

    At any point while solving the challenge, you can click the green `Check` button to get a hint suggesting something that you still need to do.

    Open the require-modules-from-pmr.sentinel policy on the "Policy" tab. The first thing you need to do is replace `<declare_imports>` with declarations of all the imports that you want to use in the policy. You need at least one and might decide to use a second, depending on how you write the policy's main condition.

    Note that this policy uses parameters like the require-even-number.sentinel policy did. While the `address` parameter has the default value `app.terraform.io`, the `organization` parameter does not have a default value. However, if you look at the pass.json and fail.json test case files on the "Test Cases" tab, you'll see that the value `Cloud-Operations` is assigned to the `organization` parameter in both of them.

    Next, you need to edit the `require_modules_from_pmr` function, replacing several placeholders in angular brackets with suitable expressions.

    Replace `<expression_1>` in the `require_modules_from_pmr` function with an expression that will give a list of all modules loaded by the root module. The `for` loop with that expression will use `name` and `m` to represent the name and data for each of these modules as it iterates across them.

    Review the [tfconfig](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig.html) import's documentation to figure out what to use. Focus on the [Namespace Overview](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig.html#namespace-overview), [Root Namespace Aliases](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig.html#root-namespace-aliases), and [Namespace: Module Configuration](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig.html#namespace-module-configuration) sections of that page.

    You now need to replace `<condition>` with a condition that requires the current module to come from the desired Private Module Registry. (Keep the parentheses around the condition.) Since this condition is placed after `not`, the function will print a violation message for modules that are **not** in the PMR and set the `validated` flag to `false`.

    You will probably want to use Sentinel's [strings](https://docs.hashicorp.com/sentinel/imports/strings) import or [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator. You can also use Sentinel's `+` operator to concatenate parameters, variables, and strings together. We also recommend looking at the mock-tfconfig-pass.sentinel mock file to see what the source of a module looks like when it is in a private module registry.

    Next, you need to replace `<expression_2>` with an expression that will include the source of the module in the violation message.

    Now that you've completed the `require_modules_from_pmr` function, you need to call it in the Rules section of the policy, replacing `<function>(<arg1>, <arg2>)` with a call to the function that passes in suitable parameters.  The result is assigned to a boolean variable, `modules_from_pmr` which is evaluated by the `main` rule.

    After making all the above substitutions, save the require-modules-from-pmr.sentinel policy.

    If you did not already look at the test cases and mock files on the "Test Cases" tab, please do that now. You'll see that fail.json refers to the mock-tfconfig-fail.sentinel mock file and expects the main rule to return false. You'll also see that pass.json refers to the mock-tfconfig-pass.sentinel mock file and expects the main rule to return true. As mentioned above, both test case files provide a value for the `organization` parameter. We also could have provided a value for the `address` parameter to override the default value set in the policy.

    Finally, test your policy:<br>
    `sentinel test -run=pmr -verbose`<br>
    Both test cases should pass with green output. Additionally, the fail test case will print a violation warning.

    If both test cases did not pass, or if Sentinel reported errors for specific lines of the policy, fix your policy and try testing it again until both test cases do pass. Examining the mock files more closely might help.
  notes:
  - type: text
    contents: |-
      In this challenge, you will complete the fifth of five exercises from the [Writing and Testing Sentinel Policies for Terraform](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform) guide.

      We recommend reviewing slide 92 of the Sentinel-for-Terraform-v1.pptx presentation or reading the [Using the Sentinel tfconfig Import](https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform#using-the-tfe-sentinel-tfconfig-import) section of that guide.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it. The mocks simulate the use of two Azure modules.
  - type: text
    contents: |-
      Your task is to write and test a Sentinel policy that requires that all modules loaded by the root module come from the [Private Module Registry](https://www.terraform.io/docs/cloud/registry/index.html) (PMR) of a Terraform Cloud organization. You will use the [tfconfig](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig.html) import to do that.

      Since the owners of a Terraform Cloud/Enterprise organization can prevent modules in their PMR from using external modules, requiring the root module to load all modules from the PMR effectively requires that all non-root modules come from the PMR.

      This policy will actually be simpler than some of the others, but we'll make you write more of it.

      You might find the documentation for Sentinel's [match operator](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) and [strings import](https://docs.hashicorp.com/sentinel/imports/strings) useful. You might also want to read about how modules are sourced from module registries [here](https://www.terraform.io/docs/modules/sources.html#terraform-registry).
  tabs:
  - title: Policy
    type: code
    hostname: sentinel
    path: /root/require-modules-from-pmr.sentinel
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/test/require-modules-from-pmr/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: extra-credit
  id: ox4dvarc3pu6
  type: challenge
  title: Extra Credit
  teaser: Prevent auto apply on production workspaces.
  assignment: |-
    In this extra credit challenge, you will use the [tfrun](https://www.terraform.io/docs/cloud/sentinel/import/tfrun.html) import to prevent production workspaces from having [Auto Apply](https://www.terraform.io/docs/cloud/workspaces/settings.html#auto-apply-and-manual-apply) enabled.

    Your task is to write and test a Sentinel policy that prevents any workspace with a name starting with "prod-" or ending in "-prod" from having the Auto Apply property set to `true`.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

    At any point while solving the challenge, you can click the green `Check` button to get a hint suggesting something that you still need to do.

    Open the prevent-auto-apply-in-production.sentinel policy on the "Policy" tab. Note that it uses the `tfrun` import.

    The first thing you need to do is replace `<condition_1>` and `<condition_2>` in the `validate_auto_apply` function with conditions that test if the workspace name starts with "prod-" or ends with "-prod". You will probably want to use Sentinel's [strings](https://docs.hashicorp.com/sentinel/imports/strings) import or [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator as you have done in earlier exercises. If you use the `strings` import, be sure to declare it at the top of the policy. If you use the `matches` operator, note that the comment at the top of the policy gives you regex expressions you can use with it.

    Next, you need to replace `<condition_3>` with a condition that requires that the workspace does not have auto apply enabled. Review the [tfrun](https://www.terraform.io/docs/cloud/sentinel/import/tfrun.html) import's documentation to figure out what to use.

    You should now replace `<expression_1>` in the `validate_auto_apply` function with an expression that gives the name of the workspace.

    After making all the above substitutions, save the prevent-auto-apply-in-production.sentinel policy.

    If you did not already look at the test cases and mock files on the "Test Cases" tab, please do that now. You'll see that there are two fail test cases and two pass test cases with corresponding mocks. These give us fail and test cases for workspace names that start with "prod-" and end with "-prod".

    Finally, test your policy:<br>
    `sentinel test -run=auto -verbose`<br>
    All 4 test cases should pass with green output. Additionally, the fail test cases will print violation warnings.

    If all 4 test cases did not pass, or if Sentinel reported errors for specific lines of the policy, fix your policy and try testing it again until all 4 test cases do pass.
  notes:
  - type: text
    contents: |-
      In this extra credit challenge, you will use the [tfrun](https://www.terraform.io/docs/cloud/sentinel/import/tfrun.html) import to prevent production workspaces from having [Auto Apply](https://www.terraform.io/docs/cloud/workspaces/settings.html#auto-apply-and-manual-apply) enabled.

      We recommend reviewing slide 93 of the Sentinel-for-Terraform-v1.pptx presentation.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.
  - type: text
    contents: |-
      Your task is to write and test a Sentinel policy that prevents any workspace with a name starting with "prod-" or ending in "-prod" from having the Auto Apply property set to `true`.

      You might find the documentation for Sentinel's [match operator](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) and [strings import](https://docs.hashicorp.com/sentinel/imports/strings) useful.
  tabs:
  - title: Policy
    type: code
    hostname: sentinel
    path: /root/prevent-auto-apply-in-production.sentinel
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/test/prevent-auto-apply-in-production/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
checksum: "5902640863005601132"
