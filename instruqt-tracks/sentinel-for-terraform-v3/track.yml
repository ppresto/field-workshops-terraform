slug: sentinel-for-terraform-v3
id: c9h6uckgsy9u
type: track
title: Sentinel for Terraform (v3)
teaser: |
  Learn how to write and test Sentinel policies for Terraform.
description: |-
  [Sentinel](https://docs.hashicorp.com/sentinel) allows customers to implement policy-as-code in the same way that Terraform implements infrastructure-as-code.

  Governance and security teams can write Sentinel policies to restrict what can be provisioned in Terraform Cloud and Terraform Enterprise workspaces. Sentinel allows these teams to control costs and enforce security standards.

  In this track, you will write and test policies that restrict resources, data sources, and modules provisioned by Terraform in AWS, Azure, and GCP. This version of the track uses the newer v2 versions of the tfplan, tfstate, and tfconfig Sentinel imports.  However, since these v2 imports can only be used with Terraform 0.12 and 0.13, if you are still using Terraform 0.11, we recommend you use the [v1 version](https://play.instruqt.com/hashicorp/tracks/sentinel-for-terraform-v1) of this track which uses the older v1 versions of those imports.

  This track is intended for use with these PowerPoint [slides](https://storage.cloud.google.com/instruqt-hashicorp-tracks/sentinel-shared/Sentinel-for-Terraform-v3.pptx) which you should download.

  You should first run the [Sentinel CLI Basics](https://play.instruqt.com/hashicorp/tracks/sentinel-cli-basics) track which introduces the Sentinel CLI.

  We recommend starting this track when you can set aside at least 4 hours of uninterrupted time. If you find yourself running out of time or are interrupted, we recommend saving all your completed policies outside the track so that you can quickly restore them if forced to begin the track again.
icon: https://storage.googleapis.com/instruqt-hashicorp-tracks/logo/terraform.png
tags:
- terraform
- sentinel
owner: hashicorp
developers:
- roger@hashicorp.com
private: false
published: true
show_timer: true
challenges:
- slug: exercise-1
  id: jlxuexs2iznt
  type: challenge
  title: Exercise 1
  teaser: |
    Restrict Vault authentication methods.
  assignment: |-
    ## Introduction
    In this challenge, you will write your first Sentinel policy for Terraform.

    Your task is to complete and test a Sentinel policy that restricts the Vault authentication methods (backends) provisioned by the `vault_auth_backend` resource of Terraform's Vault Provider to the following choices: Azure, Kubernetes, GitHub, and AppRole.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it. The policy uses the "find_resources" and "filter_attribute_not_in_list" functions from the "tfplan-functions.sentinel" module in the /root/sentinel/common-functions/tfplan-functions directory. This module was copied from [tfplan-functions.sentinel](https://github.com/hashicorp/terraform-guides/blob/master/governance/third-generation/common-functions/tfplan-functions/tfplan-functions.sentinel).

    Note that the import statement uses the alias `plan` for the "tfplan-functions" import to keep lines that use it shorter. This also makes it clear which file the module is derived from.

    At this point, we recommend you look at the tree diagram in the [Import Overview](https://www.terraform.io/docs/cloud/sentinel/import/tfplan-v2.html#import-overview) for the `tfplan/v2` import that these functions use.

    Terraform and Sentinel documentation often refer to the `attributes` of resources and data sources, but these include two different things:
      * The `arguments` which are the inputs to the resources and data sources and are specified in Terraform code.
      * The `exported attributes` which cannot be set in the Terraform code but are instead returned by the providers that provision the resources or read the data sources.

    When you search a Terraform resource or data source document for "attributes" to restrict, you will mostly be interested in its "arguments".

    When referring to an attribute in the `tfplan/v2` import, you have to use the attribute's key in the `after` map of the `change` collection of a resource or data source contained in the `resource_changes` collection. In other words, a policy evaluating attribute "x" with the `tfplan/v2` import ultimately ends up using an expression like `rc.change.after.x`.

    In this example, `rc` is an iterator variable defined in a `for` loop or in a `filter` or `all` expression that iterates over a collection of resources. Actual code will often use a different variable. The common functions used in this track and in the hashicorp/terraform-guides repository hide a lot of this from you, but it is good to understand what they are doing under the covers.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the Policy
    Open the "restrict-vault-auth-methods.sentinel" policy on the "Policies" tab. You'll see several placeholders in angular brackets throughout the policy. You need to replace those placeholders with suitable Sentinel expressions. In this and the remaining challenges, please do **not** edit the mock files; that would be cheating!

    Replace `<method1>`, `<method2>`, `<method3>`, and `<method4>` in the `allowed_methods` list with suitable values. If you did not read the second screen while this challenge was loading, we suggest you read it now by clicking on the note icon in the upper right corner and then clicking the right arrow icon. Click the X icon to return to this challenge. Be sure to check the Vault auth method pages to see what the correct values are and note that case matters.

    Next, you need to replace `<resource_type>` in the call to the "find_resources" method. We've already told you the resource type above.

    Next, replace `<attribute>` and `<list>` in the call to the "filter_attribute_not_in_list" function. You can figure out the attribute you want to restrict by reading the [auth_backend](https://www.terraform.io/docs/providers/vault/r/auth_backend.html) documentation. The name of the list to use should be obvious.

    After making all the substitutions, save the "restrict-vault-auth-methods.sentinel" policy by clicking the disk icon above the file.

    ## Examine the Test Cases and Mocks
    Now open the test cases and mock files on the "Test Cases" tab. You'll see that the "fail.json" test case refers to the "tfplan-functions.sentinel" module and the "mock-tfplan-fail.sentinel" mock file and expects the main rule to return `false`. You'll also see that the "pass.json" test case refers to the same module and the "mock-tfplan-pass.sentinel" mock file and expects the main rule to return `true`.

    The mock files are simplified versions of mocks generated from plans of Terraform Cloud runs done against Terraform code that used the Vault provider to create some auth methods. The key data that determines whether a test case will pass or fail is in the `after` stanza of the `change` stanza of resources under the `resource_changes` collection.

    The "mock-tfplan-fail.sentinel" mock file creates instances of the Kubernetes, GitHub, and AWS auth methods; the first two are allowed, but the third is not. The "mock-tfplan-pass.sentinel" mock file creates instances of the Kubernetes, GitHub, and Azure auth methods, all of which are allowed.

    ## Test the Policy
    Finally, test your policy on the "Sentinel CLI" tab:
    ```
    sentinel test -run=vault -verbose
    ```
    Both test cases should pass with green output. Additionally, the "fail.json" test case should print a violation message for the aws auth method.

    If both test cases did not pass, or if Sentinel reported errors for specific lines of the policy, fix your policy and try testing it again until both test cases do pass.
  notes:
  - type: text
    contents: |-
      [Sentinel](https://docs.hashicorp.com/sentinel) allows customers to implement policy-as-code in the same way that Terraform implements infrastructure-as-code.

      The Sentinel Command Line Interface (CLI) allows you to apply and test Sentinel policies including those that use mocks generated from Terraform Cloud and Terraform Enterprise plans.

      You should run the [Sentinel CLI Basics](https://play.instruqt.com/hashicorp/tracks/sentinel-cli-basics) track before starting this track.
  - type: text
    contents: |-
      We've launched the Sentinel CLI 0.15.6 on a Ubuntu VM running in GCP so that you don't need to download or install it.

      In this track, you will complete and test policies that have been mostly written for you but have placeholders in angular brackets that you must replace with suitable Sentinel code. When doing this, do not keep the angular brackets, but do keep any quotes that might surround them.
  - type: text
    contents: |-
      Please be sure to review all the notes screens before each challenge and to open the links in them in browser tabs outside of the Instruqt UI.

      The information in the notes and links will help you solve the challenges. We're intentionally giving you links instead of the actual information to simulate what you will have to do in the real world.

      When someone asks you to write a Sentinel policy that makes sure all S3 buckets are encrypted, they probably won't tell you which Terraform resource provisions an S3 bucket or which of its attributes determine its encryption. You're going to have to figure these things out on your own by searching for and reading relevant documentation.
  - type: text
    contents: |-
      In this challenge, you will write your first Sentinel policy for Terraform.

      We recommend reviewing the [restrict-ec2-instance-type.sentinel](https://github.com/hashicorp/terraform-guides/blob/master/governance/third-generation/aws/restrict-ec2-instance-type.sentinel) policy and slides 85-88 of the Sentinel-for-Terraform-v3.pptx presentation at this point.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it after you complete it.
  - type: text
    contents: |-
      Your task is to complete and test a Sentinel policy that restricts the Vault authentication methods (backends) provisioned by Terraform's Vault Provider.

      Don't worry if you don't know much about Vault. You'll find what you need in these URLs:
      https://www.terraform.io/docs/providers/vault/r/auth_backend.html
      https://www.vaultproject.io/docs/auth/index.html

      If you look at the links for various Vault auth methods under the second of these links, you'll see that the `vault auth enable` command always specifies the auth method type with a single lower-case string identical to or similar to the full name of the auth method. These strings are also what the Terraform Vault Provider uses when creating Vault auth methods.
  tabs:
  - title: Sentinel Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/restrict-vault-auth-methods/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 3600
- slug: exercise-2a
  id: kbpjp1jbagmm
  type: challenge
  title: Exercise 2a
  teaser: |
    Restrict AWS IAM access keys (first version).
  assignment: |-
    ## Introduction
    In this challenge and the next, you will write a second Sentinel policy for Terraform.

    Your task is to complete and test a Sentinel policy that requires that all AWS IAM access keys provisioned by Terraform's AWS Provider include a PGP key that starts with "keybase:". This means that a specific attribute on a specific resource of that provider must start with "keybase:".

    You'll complete a simple version of the policy in this challenge and then complete a more complex version in the next challenge.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the First Version
    On the "Policies" tab, you'll see that there is new policy called "require-access-keys-use-pgp-a.sentinel". Open the policy. You'll see several placeholders in angular brackets throughout the policy. You need to replace those placeholders with suitable Sentinel expressions.

    Replace `<resource_type>` in the call to the `find_resources` function in the "require-access-keys-use-pgp-a.sentinel" policy with a suitable resource type from the AWS provider. If you did not read the second screen while this challenge was loading, we suggest you read it now by clicking on the note icon in the upper right corner and then clicking the right arrow icon. Click the X icon to return to the challenge.

    Now that you have found the documentation page for the resource you are restricting, you can determine the specific attribute that is used to set a PGP key on an AWS IAM access key. Replace `<attribute>` with that attribute in the call to the "filter_attribute_does_not_have_prefix" function in the "require-access-keys-use-pgp-a.sentinel" policy.

    The "filter_attribute_does_not_have_prefix" function in the "tfplan-functions.sentinel" module does the following things:
      * Iterates over all resources in the list passed to it.
      * Calls the `evaluate_attribute` function to evaluate the value of the specified attribute for the current resource and uses the `else null` expression to convert the `undefined` value into `null` to cover the case that the resource did not have the attribute defined.
      * Checks if the value is `null`.
      * Uses the boolean expression `not strings.has_prefix(v, prefix)` to determine if the attribute does not start with the prefix (which in our case is "keybase:").
      * Adds violating resources to the `violators` map and corresponding violation messages to the `messages` map.
      * If `prtmsg` is `true`, prints warning messages for violators.
      * Returns a map with the `violators` and `messages` maps and their common length.

    Understanding this code will help you complete the "require-access-keys-use-pgp-b.sentinel" policy in the next challenge after you successfully complete and test the "require-access-keys-use-pgp-a.sentinel" policy.

    You now need to replace `<condition>` in the `main` rule of the "require-access-keys-use-pgp-a.sentinel" policy with a condition that will make the rule return `true` when there are no violations. You have already seen the condition in the slides and in exercise 1. Be sure to save the "require-access-keys-use-pgp-a.sentinel" policy.

    ## Examine the Test Cases and Mocks
    Open the test cases and mock files on the "Test Cases" tab. You'll see that we've actually included 3 fail test cases with 3 corresponding mock files. Using multiple fail test cases allows us to test multiple ways in which a policy could fail. In this case, we're testing the attribute of interest to see if it is `null`, missing, or has an invalid value that does not start with "keybase:". All 3 fail test cases expect the main rule to return `false`. Of course, we've also included a pass test case and a corresponding mock file that does include the desired attribute with an allowed value. The pass test case expects the main rule to return `true`.

    The mock files are simplified versions of mocks generated from plans of Terraform Cloud runs done against Terraform code that used the AWS provider to create an AWS IAM access key.

    ## Test the First Version
    Now, you should test your policy with this command on the "Sentinel CLI" tab:
    ```
    sentinel test -run=pgp-a.sentinel -verbose
    ```
    Setting the `-run` argument to "pgp-a.sentinel" will only match the desired policy and avoid running any other policies. All 4 test cases should pass with green output. Additionally, the 3 fail test cases should print violation messages.

    If that is not the case, you will need to edit the "require-access-keys-use-pgp-a.sentinel" policy and test the policy again until all 4 test cases pass.

    In the next challenge, you'll complete a more complex version of the policy.
  notes:
  - type: text
    contents: |-
      In this challenge, you will write the first version of a second Sentinel policy for Terraform.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

      Your task is to complete and test a Sentinel policy that requires that all AWS IAM access keys provisioned by Terraform's AWS Provider include a PGP key.
  - type: text
    contents: |-
      Don't worry if you don't know much about AWS. You can find the information you need in this URL: https://www.terraform.io/docs/providers/aws/index.html

      You can use the filter link at the top of the left-hand menu on that page to search for resources that have "access". There is only one good match that also has "key". Click on it to see what attributes are available for it.

      You'll also find the documentation for the [strings](https://docs.hashicorp.com/sentinel/imports/strings) import useful.
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/require-access-keys-use-pgp-a/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: exercise-2b
  id: 0vnfboalcoaf
  type: challenge
  title: Exercise 2b
  teaser: |
    Restrict AWS IAM access keys (second version).
  assignment: |-
    ## Introduction
    In this challenge, you will write a second version of the second Sentinel policy for Terraform.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the Second Version
    Completing the "require-access-keys-use-pgp-a.sentinel" policy should have been fairly easy since it had the same structure as the "restrict-ec2-instance-type.sentinel" and "restrict-vault-auth-methods.sentinel" policies. Almost all the exercises in this track could be solved with short policies that call functions that we have already defined. However, if you only called those functions, you would not learn how to write similar functions yourself.

    So, we would like you to pretend that the generic "filter_attribute_does_not_have_prefix" function did not exist and write your own Sentinel code to handle the specific needs of the exercise. Accordingly, please open the "require-access-keys-use-pgp-b.sentinel" policy and observe that it also has several placeholders in angular brackets that need to be replaced.

    First, in the assignment of the `pgp_key` variable, replace `<expression>` with Sentinel code that will convert `key.change.after.pgp_key` to `null` if it is missing.

    Then replace `<condition_1>` with a condition that tests if the `pgp_key` attribute was missing or null. This condition should use the `pgp_key` variable.

    Next, replace `<condition_2>` with a condition that tests if the `pgp_key` variable does **not** start with "keybase:". While there are several ways of doing this, please use the "strings" import which is also used in the "filter_attribute_does_not_have_prefix" function that was used by the "require-access-keys-use-pgp-a.sentinel" policy.

    Note that this version of the policy sets `violations` to `length(violatingIAMAccessKeys)` instead of `violatingIAMAccessKeys["length"]` since `violatingIAMAccessKeys` is just a regular map without a key called `length` as had been the case when it was returned by the filter function.

    After making all of the above substitutions, save the "require-access-keys-use-pgp-b.sentinel" policy.

    ## Test the Second Version
    Finally, test your policy:
    ```
    sentinel test -run=pgp-b.sentinel -verbose
    ```
    All 4 test cases should pass with green output. Additionally, the 3 fail test cases should print violation messages.

    If that is not the case, you will need to edit the "require-access-keys-use-pgp-b.sentinel" policy and test the policy again until all 4 test cases pass.
  notes:
  - type: text
    contents: |-
      In this challenge, you will write a second version of the second Sentinel policy for Terraform.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

      Your task is to complete and test a Sentinel policy that requires that all AWS IAM access keys provisioned by Terraform's AWS Provider include a PGP key.
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/require-access-keys-use-pgp-b/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: exercise-3a
  id: r8xoedtzzqqy
  type: challenge
  title: Exercise 3a
  teaser: |
    Restrict domains of AWS Certificate Manager (ACM) Certificates (first version).
  assignment: |-
    ## Introduction
    In this challenge, you will write a third Sentinel policy for Terraform.

    Your task is to complete and test a Sentinel policy that requires that all AWS Certificate Manager (ACM) Certificates referenced by a data source in Terraform's AWS Provider have domains that are subdomains of "hashidemos.io".

    You'll complete a simple version of the policy in this challenge and then complete a more complex version in the next challenge.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it. The policy uses the "find_datasources" function from the "tfstate-functions.sentinel" module in the /root/sentinel/common-functions/tfstate-functions directory. This module was copied from [tfstate-functions.sentinel](https://github.com/hashicorp/terraform-guides/blob/master/governance/third-generation/common-functions/tfstate-functions/tfstate-functions.sentinel).

    Note that the import statement uses the alias `state` for the "tfstate-functions" import to keep lines that use it shorter. This also makes it clear which file the module is derived from.

    At this point, we recommend you look at the tree diagram in the [Import Overview](https://www.terraform.io/docs/cloud/sentinel/import/tfstate-v2.html#import-overview) for the `tfstate/v2` import.

    When referring to an attribute in the `tfstate/v2` import, you have to use the attribute's key in the `values` map of a resource or data source contained in the import's `resources` collection. So, a policy evaluating attribute "x" with the `tfstate/v2` import ultimately ends up using an expression like `r.values.x`. (Recall that the `tfplan/v2` import uses an expression like `rc.change.after.x`.)

    In this example, `r` is an iterator variable defined in a `for` loop or in a `filter` or `all` expression that iterates over a collection of resources. Actual code will often use a different variable. Of course, the common functions used in this track and in the hashicorp/terraform-guides repository hide a lot of this from you, but it is good to understand what they are doing under the covers.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the First Version
    Open the "restrict-acm-certificate-domains-a.sentinel" policy on the "Policies" tab.

    You'll see several placeholders in angular brackets throughout the policy. You need to replace those placeholders with suitable Sentinel expressions.

    Replace `<data_source_type>` in the call made to the `find_datasources` function in the "restrict-acm-certificate-domains-a.sentinel" policy with a suitable data source type from the AWS provider. If you did not read the second screen while this challenge was loading, we suggest you read it now by clicking on the note icon in the upper right corner and then clicking the right arrow icon. Click the X icon to return to the challenge.

    Now that you have found the documentation page for the data source you are restricting, you can determine the specific attribute that is used to set the domain on an ACM certificate. Please replace `<attribute>` in the "restrict-acm-certificate-domains-a.sentinel" policy with that attribute.

    You next need to replace `<expression>` with a suitable expression representing the value of the domain. By this point, the right expression should already be in your policy.

    ## Examine the Test Cases and Mocks
    Now open the test cases and mock files on the "Test Cases" tab. You'll see that the "fail.json" test case refers to the "tfstate-functions.sentinel" module and the "mock-tfstate-fail.sentinel" mock file and expects the main rule to return `false`. You'll also see that the "pass.json" test case refers to the same module and the "mock-tfstate-pass.sentinel" mock file and expects the main rule to return `true`.

    The mock files are simplified versions of mocks generated from plans of Terraform Cloud runs done against Terraform code that used the AWS provider to retrieve information from two AWS ACM certificates.

    ## Test the First Version
    Now, you should test your policy on the "Sentinel CLI" tab with this command:
    ```
    sentinel test -run=domains-a.sentinel -verbose
    ```
    Setting the `-run` argument to "domains-a.sentinel" will only match the desired policy and avoid running other policies. Both test cases should pass with green output. Additionally, they will both print messages indicating whether domains were valid or not.

    If that is not the case, you will need to edit the "restrict-acm-certificate-domains-a.sentinel" policy and test the policy again until both test cases pass.

    In the next challenge, you will complete a more complex version of the same policy.
  notes:
  - type: text
    contents: |-
      In this challenge, you will write a third Sentinel policy for Terraform.

      We recommend reviewing slides 108-110 of the Sentinel-for-Terraform-v3.pptx presentation.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.
  - type: text
    contents: |-
      Your task is to complete and test a Sentinel policy that requires that all AWS Certificate Manager (ACM) Certificates referenced by a data source in Terraform's AWS Provider have domains that are subdomains of "hashidemos.io". (This means the domains must end in ".hashidemos.io".)

      As in Exercise 2, you can look at the [AWS Provider](https://www.terraform.io/docs/providers/aws/index.html) documentation to search for the relevant data source.

      You can use the filter link at the top of the left-hand menu on that page to search for a data source that has "acm". Click on it to see what attributes are available for it.

      You might also find the documentation for the Sentinel [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator useful.
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/restrict-acm-certificate-domains-a/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: exercise-3b
  id: zimhkwdx4ehq
  type: challenge
  title: Exercise 3b
  teaser: |
    Restrict domains of AWS Certificate Manager (ACM) Certificates (second version).
  assignment: |-
    ## Introduction
    In this challenge, you will write a second version of the third Sentinel policy for Terraform.

    The policy will require that all AWS Certificate Manager (ACM) Certificates referenced by a data source in Terraform's AWS Provider have domains that are subdomains of "hashidemos.io".

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the Second Version
    The second version of the policy uses an embedded function, `validate_certs`, to validate that evaluated ACM certs meet the desired conditions. Accordingly, please open the "restrict-acm-certificate-domains-b.sentinel" policy and observe that it also has several placeholders in angular brackets that need to be replaced.

    Note that the `validate_certs` function uses a different approach than was used in exercises 1 and 2. Instead of creating a list of resources that violate some condtion, it uses a boolean variable, `validated`, that is initially set to `true`, iterates over all resources passed to it, and sets `validated` to `false` if there are any violations. It returns the value of the `validated` variable. The main rule of the policy then checks whether it returns `true` or `false`.

    Open the "restrict-acm-certificate-domains-b.sentinel" policy on the "Policies" tab.

    Start your modifications by replacing `<expression>` with an expression that will assign the value of the current certificate's domain to the `domain` variable. If you're unsure what to use, look at your completed "restrict-acm-certificate-domains-a.sentinel" policy.

    You now need to replace `<condition>` in the definition of the `validate_certs` function with a condition that checks that the domain of the ACM certificate set in the `domain` variable is a subdomain of the `parent_domain` argument of the function. We would like you to use the [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator.

    Now that you've completed the `validate_certs` function, you need to call it, replacing `<regex>` with a regular expression that ensures that the domains of the ACM certificates contained in the `allACMCerts` list end in ".hashidemos.io".

    After making all the above substitutions, be sure to save the restrict-acm-certificate-domains-b.sentinel policy.

    ## Test the Second Version
    Finally, test your policy on the "Sentinel CLI" tab with this command:
    ```
    sentinel test -run=domains-b.sentinel -verbose
    ```

    Both test cases should pass with green output. Additionally, they will both print messages indicating whether domains were valid or not.

    If that is not the case, you will need to edit the "restrict-acm-certificate-domains-b.sentinel" policy and test the policy again until both test cases pass.
  notes:
  - type: text
    contents: |-
      In this challenge, you will write a second version of a third Sentinel policy for Terraform.

      We recommend reviewing slides 35 and 45 of the Sentinel-for-Terraform-v3.pptx presentation.

      In this exercise, you will write your own function and use the [tfstate/v2](https://www.terraform.io/docs/cloud/sentinel/import/tfstate-v2.html) import and the [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator.
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/restrict-acm-certificate-domains-b/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: exercise-4a
  id: wvxmgejuyhef
  type: challenge
  title: Exercise 4a
  teaser: |
    Restrict images used by Google Cloud Platform compute instances (first version).
  assignment: |-
    ## Introduction
    In this challenge, you will write a fourth Sentinel policy for Terraform.

    Your task is to complete and test a Sentinel policy that requires Google Cloud Platform (GCP) compute instances provisioned by Terraform's Google Provider to use the public image "debian-cloud/debian-9". In a real-world policy, you would allow multiple images, but we wanted to keep things simple for this exercise.

    You'll complete a simple version of the policy in this challenge and then complete a more complex version in the next challenge.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it. The policy uses the "find_resources" function from the "tfplan-functions.sentinel" module in the /root/sentinel/common-functions/tfplan-functions directory.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the First Version
    Open the "restrict-gcp-instance-image-a.sentinel" policy on the "Policies" tab. You'll see several placeholders in angular brackets throughout the policy. You need to replace those placeholders with suitable Sentinel expressions.

    Replace `<resource_type>` in the call to the `find_resources` function with the correct resource type from the Google provider.

    Now that you have found the documentation page for the resource you are restricting, you can determine the specific attribute that is used to set the image on a Google compute instance. This attribute is nested inside one block which is itself contained in a second block. Each of these blocks can only occur once.

    In Sentinel, a block is treated as a list of maps. Additionally, lists are indexed starting with 0. We would use the expression, `x[0].y[0].z`, to refer directly to the attribute `z` of the first map inside the `y` block of the first map inside the `x` block of a resource. However, the `evaluate_attribute` function called by the `filter_attribute_is_not_value` function expects an expression like `x[0].y[0].z` to be given as `x.0.y.0.z`.

    You now need to replace `<expression_1>` in the "restrict-gcp-instance-image-a.sentinel" policy with a reference to the attribute that represents the image of a Google compute instance. Use an expression like the final one given in the last paragraph.

    Next, you need to replace `<expression_2>` in the "restrict-gcp-instance-image-a.sentinel" policy with an expression that gives the number of GCP compute instances with violations. This expression will be similar to expressions that have been assigned to the `violations` variable in earlier exercises.

    ## Examine the Test Cases and Mocks
    Now open the test cases and mock files on the "Test Cases" tab. You'll see that the test cases, "fail-invalid-image.json" and "fail-no-initialize-params.json", refer to the "mock-tfplan-fail-invalid-image.sentinel" and "mock-tfplan-fail-no-initialize-params.sentinel" mock files respectively and expect the main rule to return `false`. You'll also see that the test case, "pass.json", refers to the "mock-tfplan-pass.sentinel" mock file and expects the main rule to return `true`. All 3 test cases also refer to the "tfplan-functions.sentinel" module.

    The mock files are simplified versions of mocks generated from plans of Terraform Cloud runs done against Terraform code that used the Google provider to create a GCE compute instance. The "mock-tfplan-fail-no-initialize-params.sentinel" mock file was generated from a Terraform configuration that first generated a GCE compute disk and then created a GCE compute instance from it, avoiding the need to use the `initialize_params` block of the compute instance resource. The other two mocks created the compute instance resource directly from standard images.

    ## Test the First Version
    Now, you should test your policy on the "Sentinel CLI" tab with this command:
    ```
    sentinel test -run=image-a.sentinel -verbose
    ```
    Setting the `-run` argument to "image-a.sentinel" will only match the desired policy and avoid running other policies. All 3 test cases should pass with green output. Additionally, the fail tests will print messages indicating that an image was either not defined or not allowed.

    If that is not the case, you will need to edit the "restrict-gcp-instance-image-a.sentinel" policy and test the policy again until all 3 test cases pass.

    In the next challenge, you will complete a second version of this policy.
  notes:
  - type: text
    contents: |-
      In this challenge, you will write a fourth Sentinel policy for Terraform.

      You will learn how to evaluate an attribute that is contained in a block contained in another block of a resource. A block is treated by Sentinel as a list of maps. We recommend reviewing slides 112-115 of the Sentinel-for-Terraform-v3.pptx presentation.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.
  - type: text
    contents: |-
      Your task is to complete and test a Sentinel policy that requires Google Cloud Platform (GCP) compute instances provisioned by Terraform's Google Provider to use the public image "debian-cloud/debian-9".

      Don't worry if you don't know much about GCP. You can look at the [Google Provider](https://www.terraform.io/docs/providers/google/index.html) documentation to find the relevant GCP resource. (Be sure to pick a resource and not a data source with the same name.)

      You might also find the documentation for Sentinel [lists](https://docs.hashicorp.com/sentinel/language/lists), [maps](https://docs.hashicorp.com/sentinel/language/maps), and the standard [types](https://docs.hashicorp.com/sentinel/imports/types) import useful.
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/restrict-gcp-instance-image-a/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: exercise-4b
  id: 5xp14zhwzspf
  type: challenge
  title: Exercise 4b
  teaser: |
    Restrict images used by Google Cloud Platform compute instances (second version).
  assignment: |-
    ## Introduction
    In this challenge, you will write a second version of the fourth Sentinel policy for Terraform.

    Your task is to complete and test a Sentinel policy that requires Google Cloud Platform (GCP) compute instances provisioned by Terraform's Google Provider to use the public image "debian-cloud/debian-9". In a real-world policy, you would allow multiple images, but we wanted to keep things simple for this exercise.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the Second Version
    The second version of the policy uses an embedded function, `filter_images`, to validate that evaluated GCP compute instances meet the desired conditions.

    Accordingly, please open the "restrict-gcp-instance-image-b.sentinel" policy and observe that it also has several placeholders in angular brackets that need to be replaced.

    First, replace `<expression_1>` in the line that assigns a value to the `boot_disk` variable with an expression that gives the data of the `boot_disk` block of the "google_compute_instance" resource. For a hint about the structure of your replacement, see line 18 of the "require-access-keys-use-pgp-b.sentinel" policy on the "Policies" tab, but don't bother adding `else null` to your expression.

    We use the `types` import to check if `<expression_2>` is a list since we will try to access elements of it in the `else` statement and would get an error if it is not a list (which would be the case if it were missing or `null`). We did not need to check the type of the `boot_disk` block because it is a required block of the resource and therefore cannot be missing.

    So, please replace `<expression_2>` with an expression that gives the data of the `initialize_params` block of the first map of the `boot_disk` block.  Use the `[n].` notation rather than the `.n.` notation that the `evaluate_attribute` function requires.

    You now need to replace two occurences of `<expression_3>` in the `filter_images` function with a complex expression that refers to the value of the image set in the first `initialize_params` block of the first `boot_disk` block. In addition to specifying the correct attribute of the `initialize_params` block, keep in mind that it needs to be indexed just like `boot_disk` block was indexed. Your replacement for `<expression_3>` should start with what you used when replacing `<expression_2>`.

    Finally, you need to replace `<add_main_rule>` with a main rule that evaluates the number of GCP compute instances that had violations. This will look very similar to the main rule in your other policies.

    After making all the above substitutions, save the restrict-gcp-instance-image-b.sentinel policy.

    ## Test the Second Version
    Finally, test your policy on the "Sentinel CLI" tab with this command:
    ```
    sentinel test -run=image-b.sentinel -verbose
    ```

    All 3 test cases should pass with green output. Additionally, the fail test cases will print messages indicating that the image was not defined or invalid.

    If that is not the case, you will need to edit the "restrict-gcp-instance-image-b.sentinel" policy and test the policy again until all 3 test cases pass.
  notes:
  - type: text
    contents: |-
      In this challenge, you will write a second version of the fourth Sentinel policy for Terraform.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

      Your task is to complete and test a Sentinel policy that requires Google Cloud Platform (GCP) compute instances provisioned by Terraform's Google Provider to use the public image "debian-cloud/debian-9".
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/restrict-gcp-instance-image-b/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: exercise-5a
  id: jkxykckoqz3m
  type: challenge
  title: Exercise 5a
  teaser: |
    Only allow modules from the Private Module Registry (first version).
  assignment: |-
    ## Introduction
    In this challenge, you will write a fifth Sentinel policy for Terraform.

    Your task is to complete and test a Sentinel policy that requires that all modules loaded by the root module come from the [Private Module Registry](https://www.terraform.io/docs/cloud/registry/index.html) (PMR) of a Terraform Cloud organization.

    You'll complete a simple version of the policy in this challenge and then complete a more complex version in the next challenge.

    We recommend reviewing this [doc](https://www.terraform.io/docs/cloud/registry/using.html) that describes how to specify the `source` for a module in a Private Module Registry on a Terraform Cloud or Terraform Enterprise server.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it. The mocks simulate the use of two Azure modules.

    At this point, we recommend you look at the tree diagram in the [Import Overview](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig-v2.html#import-overview) for the `tfconfig/v2` import that the policy uses.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the First Version
    Open the "require-modules-from-pmr-a.sentinel" policy on the "Policies" tab. You'll see several placeholders in angular brackets throughout the policy. You need to replace those placeholders with suitable Sentinel expressions.

    Note that this policy uses parameters like the "require-even-number.sentinel" policy did. While the `address` parameter has the default value `app.terraform.io`, the `organization` parameter does not have a default value. However, if you look at the "pass.json" and "fail.json" test case files on the "Test Cases" tab, you'll see that the value `Cloud-Operations` is assigned to the `organization` parameter in both of them.

    Replace `<expression_1>` in the `require_modules_from_pmr` function with an expression that gives a list of all module calls. The `for` loop with that expression uses `index` and `mc` to represent the index and data for each of these module calls as it iterates across them. See the [module_calls](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig-v2.html#the-module_calls-collection) section of the `tfconfig/v2` documentation for more details.

    We only want the policy to restrict module calls made from the root module. While module calls generally have an index with the form `<module_address>:<name>`, the first part, `<module_address>:`, is ommitted for module calls made from the root module.

    Accordingly, replace `<condition_1>` with a condition that requires the current module call to have an index that does not contain a colon. There are at least two ways of doing this with the [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator:

      1. The simpler way uses `if index matches "<regex1>"` in which <regex1\> uses `.+` or `(.+)` twice to match one or more characters.
      2. The slightly more complex way uses `if index matches "<regex2>"` in which <regex2\> contains a [negated character class](https://www.regular-expressions.info/charclass.html) and ensures that nothing in it occurs from the beginning (^) to the end ($) of the index.

    Next, you need to replace `<condition_2>` with a condition that tests if the module call has a `source` from the desired Private Module Registry. Since this condition is placed after `not`, the function will print a violation message for modules that are not in the PMR and set the `validated` flag to `false`.

    While you could use the `matches` operator in your replacement of `<condition_2>`, **please use the `has_prefix` function from Sentinel's [strings](https://docs.hashicorp.com/sentinel/imports/strings) import in your solution**.

    In general, a well-designed function should not reference things defined outside of it. So, please do not reference the Sentinel parameters, `address` and `organization` from the top of the policy; instead, reference the function's arguments, `tf_address` and `tf_org`.

    You can use Sentinel's `+` operator to concatenate variables and strings together. In fact, you'll see a useful example in the second violation message.

    Next, you need to replace `<expression_2>` with an expression that gives the source of the module in the violation message.

    Now that you've completed the `require_modules_from_pmr` function, you need to call it, replacing `<function>(<arg1>, <arg2>)` with a call to the function that passes in suitable arguments to it. The result is assigned to a boolean variable, `modules_from_pmr` which is evaluated by the `main` rule. This would be a good place to use the Sentinel parameters, `address` and `organization`, defined at the top of the policy. Also, you can concatentate variables and static strings with the `+` operator.

    After making all the above substitutions, save the "require-modules-from-pmr-a.sentinel" policy by clicking the disk icon above the file.

    ## Examine the Test Cases and Mocks
    Now open the test cases and mock files on the "Test Cases" tab. You'll see that the "fail.json" test case refers to the "mock-tfconfig-fail.sentinel" mock file and expects the main rule to return false. You'll also see that the "pass.json" test case refers to the "mock-tfconfig-pass.sentinel" mock file and expects the main rule to return true.

    As mentioned above, both test case files provide a value for the `organization` parameter. We also could have provided a value for the `address` parameter to override the default value set in the policy. We would do that if using a Terraform Enterprise server instead of the Terraform Cloud deployment hosted by HashiCorp.

    The mock files are simplified versions of mocks generated from plans of Terraform Cloud runs done against Terraform code that used the Azure provider to provision Azure resources including resource groups, network resources, security group resources, and VMs. The "mock-tfconfig-fail.sentinel" mock uses modules from the public [Terraform Registry](https://registry.terraform.io/) while the "mock-tfconfig-pase.sentinel" mock uses modules from a PMR in the "Cloud-Operations" organization on the Terraform Cloud server ("app.terraform.io").

    ## Test the First Version
    Now, you should test your policy on the "Sentinel CLI" tab with this command:
    ```
    sentinel test -run=pmr-a.sentinel -verbose
    ```
    Setting the `-run` argument to "pmr.sentinel" will only match the desired policy and avoid running other policies. Both test cases should pass with green output. Additionally, the fail test case will print messages indicating that the root module of the Terraform configuration called modules that are not from the desired private module registry.

    If that is not the case, you will need to edit the "require-modules-from-pmr-a.sentinel" policy and test the policy again until both test cases pass.

    In the next challenge, you will complete a second version of the policy.
  notes:
  - type: text
    contents: |-
      In this challenge, you will write a fifth Sentinel policy for Terraform.

      We recommend reviewing slides 117-120 of the Sentinel-for-Terraform-v3.pptx presentation.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it. The mocks simulate the use of two Azure modules both from the public Terraform Registry and from a Private Module Registry in an organization on the Terraform Cloud server.
  - type: text
    contents: |-
      Your task is to complete and test a Sentinel policy that requires that all modules called by the root module come from the [Private Module Registry](https://www.terraform.io/docs/cloud/registry/index.html) (PMR) of a Terraform Cloud organization called "Cloud-Operations". You will use the [tfconfig/v2](https://www.terraform.io/docs/cloud/sentinel/import/tfconfig-v2.html) import to do that.

      Since the owners of a Terraform Cloud/Enterprise organization can prevent modules in their PMR from using external modules, requiring the root module to call all modules from the PMR effectively requires that all non-root modules come from the PMR.

      You might find the documentation for Sentinel's [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator and [strings](https://docs.hashicorp.com/sentinel/imports/strings) import useful. You might also want to read about how modules are sourced from private module registries [here](https://www.terraform.io/docs/cloud/registry/using.html).
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/require-modules-from-pmr-a/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: exercise-5b
  id: fx1mwkiag5bx
  type: challenge
  title: Exercise 5b
  teaser: |
    Only allow modules from the Private Module Registry (second version).
  assignment: |-
    ## Introduction
    In this challenge, you will write a second version of the fifth Sentinel policy for Terraform.

    Your task is to complete and test a Sentinel policy that requires that all modules loaded by the root module come from the [Private Module Registry](https://www.terraform.io/docs/cloud/registry/index.html) (PMR) of a Terraform Cloud organization.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the Second Version
    In this challenge, we would like you to move your completed `require_modules_from_pmr` function into the file, "module-functions.sentinel", so that it can be called by other policies as a Sentinel module. We then want you to modify the "require-modules-from-pmr-b.sentinel" policy to call the function from that file.

    Here are the steps you should follow:

      1. Copy the entire `require_modules_from_pmr` function to the bottom of the "module-functions.sentinel" file that is in the /root/sentinel/common-functions/module-functions directory.
      1. Save the "module-functions.sentinel" file.
      1. Replace `<import_statement>` in the "require-modules-from-pmr-b.sentinel" policy with a suitable import statement that will allow that policy to call the function from the "module-functions.sentinel" file. We recommend that you look at the test cases to see the name they are using for the module that points at that file. **Please use the alias `modules`.**
      1. Replace `<function_call>` with a call to the `require_modules_from_pmr` function in the module referenced by the import statement you just added. Be sure to include two suitable arguments in the function call.
      1. Save the "require-modules-from-pmr-b.sentinel" policy.

    ## Examine the Test Cases and Mocks
    Now open the test cases and mock files on the "Test Cases" tab. These are like the ones in the previous challenge, but both test cases also refer to the "module-functions.sentinel" module that you just wrote.

    ## Test the Second Version
    Finally, test your policy on the "Sentinel CLI" tab with this command:
    ```
    sentinel test -run=pmr-b.sentinel -verbose
    ```

    Both test cases should pass with green output. Additionally, the fail test case will print messages indicating that the root module of the Terraform configuration called modules that are not from the desired private module registry.

    If that is not the case, you will need to edit the "require-modules-from-pmr-b.sentinel" policy and test the policy again until both test cases pass.
  notes:
  - type: text
    contents: |-
      In this challenge, you will write a second version of the fifth Sentinel policy for Terraform.

      You will also move the `require_modules_from_pmr` function you wrote in the last challenge into a module and then call it from the second version of the policy.
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/require-modules-from-pmr-b/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
- slug: extra-credit
  id: i9ujmhos1z04
  type: challenge
  title: Extra Credit
  teaser: |
    Prevent auto apply on production workspaces.
  assignment: |-
    ## Introduction
    In this extra credit challenge, you will use the [tfrun](https://www.terraform.io/docs/cloud/sentinel/import/tfrun.html) import to prevent production workspaces from having [Auto Apply](https://www.terraform.io/docs/cloud/workspaces/settings.html#auto-apply-and-manual-apply) enabled.

    Your task is to complete and test a Sentinel policy that prevents any workspace with a name starting with "prod-" or ending in "-prod" from having the Auto Apply property set to `true`.

    We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.

    At any point while solving the challenge, you can click the green "Check" button to get a hint suggesting something that you still need to do.

    ## Complete the Policy
    Open the "prevent-auto-apply-in-production.sentinel" policy on the "Policies" tab. Note that it uses the `tfrun` import.

    The first thing you need to do is replace `<condition_1>` and `<condition_2>` in the `validate_auto_apply` function with conditions that test if the workspace name starts with "prod-" or ends with "-prod". You will probably want to use Sentinel's [strings](https://docs.hashicorp.com/sentinel/imports/strings) import or [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator as you have done in earlier challenges. If you use the `strings` import, be sure to declare it at the top of the policy. If you use the `matches` operator, note that the comment at the top of the policy gives you regex expressions you can use with it.

    Next, you need to replace `<condition_3>` with a condition that tests if the workspace has auto apply enabled. Review the [tfrun](https://www.terraform.io/docs/cloud/sentinel/import/tfrun.html) import's documentation to figure out what to use.

    You should now replace `<expression_1>` in the `validate_auto_apply` function with an expression that gives the name of the workspace.

    After making all the above substitutions, save the "prevent-auto-apply-in-production.sentinel" policy.

    # Examine the Test Cases and Mocks
    Please review the test cases and mock files on the "Test Cases" tab. You'll see that there are two fail test cases and two pass test cases with corresponding mocks. These give us fail and test cases for workspace names that start with "prod-" and end with "-prod".

    ## Test the Policy
    Finally, test your policy:
    ```
    sentinel test -run=auto -verbose
    ```
    All 4 test cases should pass with green output. Additionally, the fail test cases will print violation warnings.

    If all 4 test cases did not pass, or if Sentinel reported errors for specific lines of the policy, fix your policy and try testing it again until all 4 test cases do pass.

    Congratulations on completing the Sentinel in Terraform track! This is one of the more challenging workshop tracks.  Well done, if you were able to complete all the policies.  And kudos for trying even if you struggled a bit. Perhaps you can go through it a second time and do better?
  notes:
  - type: text
    contents: |-
      In this extra credit challenge, you will use the [tfrun](https://www.terraform.io/docs/cloud/sentinel/import/tfrun.html) import to prevent production workspaces from having [Auto Apply](https://www.terraform.io/docs/cloud/workspaces/settings.html#auto-apply-and-manual-apply) enabled.

      We recommend reviewing slides 127-130 of the Sentinel-for-Terraform-v3.pptx presentation.

      We've made things easier by writing most of the policy for you and by providing the test cases and mocks that you need to test it.
  - type: text
    contents: |-
      Your task is to complete and test a Sentinel policy that prevents any workspace with a name starting with "prod-" or ending in "-prod" from having the Auto Apply property set to `true`.

      You might find the documentation for Sentinel's [matches](https://docs.hashicorp.com/sentinel/language/spec/#matches-operator) operator and [strings](https://docs.hashicorp.com/sentinel/imports/strings) import useful.
  tabs:
  - title: Policies
    type: code
    hostname: sentinel
    path: /root/sentinel/
  - title: Test Cases
    type: code
    hostname: sentinel
    path: /root/sentinel/test/prevent-auto-apply-in-production/
  - title: Sentinel CLI
    type: terminal
    hostname: sentinel
  difficulty: basic
  timelimit: 1800
checksum: "12770385458511956458"
